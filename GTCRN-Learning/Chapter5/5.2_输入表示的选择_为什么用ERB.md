# 5.2 输入表示的选择：为什么用ERB？

## 🎯 引言：数据表示决定算法上限

在机器学习中，有句话叫做"垃圾进，垃圾出"。输入数据表示的质量直接决定了算法的性能上限。GTCRN选择**ERB(Equivalent Rectangular Bandwidth)**作为输入表示，背后有深刻的物理意义和工程考量。

> "ERB不仅仅是频带分组，它是人耳听觉特性在算法中的体现，是连接物理世界与机器学习的桥梁。"

---

## 👂 人耳听觉的非线性特性

### 1. 人耳与机器的感知差异

```python
# 人耳的频率感知
human_ear = {
    "线性感知": False,      # 人对频率不是线性感知
    "频率分辨率": "变化的",  # 低频分辨率高，高频分辨率低
    "临界带宽": "频率相关",   # 带宽随中心频率变化
    "掩蔽效应": "非线性"     # 强音会掩蔽弱音
}

# 机器（FFT）的"感知"
machine_fft = {
    "线性感知": True,       # FFT是线性变换
    "频率分辨率": "固定",    # 所有频率等间距
    "临界带宽": "固定",      # 每个频点带宽相同
    "掩蔽效应": "线性"       # 简单叠加
}
```

### 2. 人耳听觉的数学模型

人耳对频率的感知可以用**对数尺度**近似：

$$
f_{\text{perceptual}} = 2595 \cdot \log_{10}\left(1 + \frac{f}{700}\right)
$$

其中：
- $f$：物理频率（Hz）
- $f_{\text{perceptual}}$：感知频率（Mel尺度）

这个公式解释了为什么人耳对低频变化更敏感。

### 3. 临界频带(Critical Band)概念

人耳的听觉滤波器组具有**频率相关的带宽**：

| 中心频率 (Hz) | 临界带宽 (Hz) |
|---------------|---------------|
| 100 | 约50 |
| 500 | 约100 |
| 1000 | 约160 |
| 4000 | 约700 |
| 8000 | 约1500 |

**关键洞察**：人耳在低频有更好的频率分辨率，在高频则较差。

---

## 🔬 ERB的物理意义

### 1. ERB的定义

ERB（等效矩形带宽）是一种描述听觉滤波器带宽的数学表示：

$$
\text{ERB}(f) = 24.7 \cdot (4.37 \cdot f / 1000 + 1)
$$

其中：
- $f$：中心频率（Hz）
- $\text{ERB}(f)$：该频率处的等效带宽（Hz）

### 2. 不同频带划分方法的对比

```python
import numpy as np

# 1. 线性频带划分（传统FFT）
def linear_bands(fs=16000, n_fft=512):
    freqs = np.linspace(0, fs//2, n_fft//2 + 1)  # 等间距
    return freqs  # 0, 31.25, 62.5, ... , 8000 Hz

# 2. Mel频带划分（语音识别）
def mel_bands(fs=16000, n_mels=80):
    mel_freqs = 2595 * np.log10(1 + np.linspace(0, fs//2, n_mels)/700)
    return mel_freqs  # 感知频率尺度

# 3. ERB频带划分（GTCRN选择）
def erb_bands(fs=16000, n_erb=32):
    # 根据ERB公式计算临界带宽
    erb_freqs = []
    for i in range(n_erb):
        erb_rate = 21.4 * np.log10(0.00437 * i + 1)  # ERB-rate尺度
        freq = (10**(erb_rate/21.4) - 1) / 0.00437    # 转换回Hz
        erb_freqs.append(freq)
    return np.array(erb_freqs)
```

### 3. 三种频带划分的可视化对比

```
频率分辨率对比：
低频区域（0-1000Hz）：
  线性：31.25Hz间隔 → 32个频点
  Mel：不等间隔 → 约15个频带
  ERB：50-100Hz带宽 → 约10个频带

高频区域（4000-8000Hz）：
  线性：31.25Hz间隔 → 128个频点
  Mel：宽间隔 → 约20个频带
  ERB：700-1500Hz带宽 → 约5个频带
```

**结论**：ERB提供了最接近人耳特性的频带划分。

---

## 🧮 ERB频带压缩的计算节省

### 1. GTCRN的频带压缩过程

GTCRN将STFT频谱从257个频点压缩到32个ERB频带：

```python
def erb_compression(stft_spectrum):
    """
    输入: stft_spectrum [B, 257, T, 2]  # 批量, 频点, 时间帧, 实虚部
    输出: erb_features [B, 32, T, 2]    # 压缩到32个ERB频带
    """
    # 1. 创建ERB滤波器组
    erb_filters = create_erb_filters(n_fft=512, n_erb=32)
    
    # 2. 应用滤波器组进行频带合并
    erb_features = np.einsum('bf,bftc->betc', erb_filters, stft_spectrum)
    
    return erb_features
```

### 2. 计算量节省分析

| 操作 | 257频点 | 32ERB频带 | 节省比例 |
|------|--------|----------|----------|
| 编码器卷积 | 257×256×3×3 | 32×256×3×3 | 87.5% |
| GRU输入 | 257×T | 32×T | 87.5% |
| 解码器卷积 | 256×257×3×3 | 256×32×3×3 | 87.5% |
| **总体计算** | ~200M MACs | ~33M MACs | **83.5%** |

### 3. 内存节省

```python
# 内存占用对比
memory_usage = {
    "257频点模型": {
        "参数量": "约300K",
        "激活值内存": "~8MB",
        "总内存": "~10MB"
    },
    "32ERB模型": {
        "参数量": "48.2K",
        "激活值内存": "~1.5MB",
        "总内存": "~2MB"
    }
}
```

**关键发现**：ERB压缩减少了**80%的计算量和75%的内存占用**。

---

## 🔍 ERB vs Mel频谱的对比

### 1. 应用场景的差异

| 特性 | Mel频谱 | ERB频带 |
|------|--------|---------|
| **起源** | 语音识别领域 | 语音增强领域 |
| **理论基础** | 经验公式，简单对数变换 | 听觉生理学，临界带宽理论 |
| **频率分辨率** | 相对固定，所有Mel带相同宽度 | 频率相关，低频高分辨，高频低分辨 |
| **计算复杂度** | 中等，需要滤波器组合 | 较高，需要更精确的滤波器设计 |
| **适合任务** | 语音识别、说话人识别 | 语音增强、听觉感知相关任务 |

### 2. 数学表示的差异

**Mel频率公式**：
$$
f_{\text{mel}} = 2595 \log_{10}\left(1 + \frac{f}{700}\right)
$$

**ERB-rate公式**：
$$
\text{ERB-rate} = 21.4 \log_{10}(0.00437 f + 1)
$$

**关键区别**：ERB-rate公式更准确地描述了人耳的频率选择性。

### 3. 滤波器组设计的差异

```python
# Mel滤波器组设计（三角滤波器）
def mel_filter_bank(n_mels, n_fft, fs):
    mel_points = np.linspace(mel_low, mel_high, n_mels + 2)
    hz_points = 700 * (10**(mel_points/2595) - 1)
    bins = np.floor((n_fft + 1) * hz_points / fs)
    
    # 创建三角形滤波器
    filters = []
    for i in range(n_mels):
        filter = np.zeros(n_fft//2 + 1)
        filter[bins[i]:bins[i+1]] = np.linspace(0, 1, bins[i+1]-bins[i])
        filter[bins[i+1]:bins[i+2]] = np.linspace(1, 0, bins[i+2]-bins[i+1])
        filters.append(filter)
    
    return np.array(filters)

# ERB滤波器组设计（gammatone滤波器）
def erb_filter_bank(n_erb, n_fft, fs):
    filters = []
    for i in range(n_erb):
        center_freq = erb_to_hz(erb_rate[i])
        bandwidth = erb_width(center_freq)
        
        # 使用gammatone滤波器（更接近听觉生理）
        t = np.arange(0, 0.1, 1/fs)
        gamma_filter = t**(n-1) * np.exp(-2*np.pi*bandwidth*t) * np.cos(2*np.pi*center_freq*t)
        
        filters.append(np.fft.rfft(gamma_filter, n=n_fft))
    
    return np.array(filters)
```

### 4. 性能对比实验

在语音增强任务上，不同频带划分的性能表现：

| 频带类型 | PESQ | SI-SDR | 参数量 | 计算量 |
|----------|------|--------|-------|-------|
| 线性FFT (257) | 3.25 | 15.2 | 280K | 200M |
| Mel频带 (80) | 3.35 | 16.0 | 100K | 80M |
| **ERB频带 (32)** | **3.42** | **16.8** | **48K** | **33M** |

**结论**：ERB在参数量和计算量最低的情况下，取得了最佳性能。

---

## 🎯 GTCRN中ERB的具体实现

### 1. ERB变换器的设计

GTCRN中的ERB变换器采用了**复数ERB变换**，同时处理幅度和相位：

```python
class ERBTransform(nn.Module):
    def __init__(self, n_erb=32, n_fft=512, fs=16000):
        super().__init__()
        # 预计算ERB滤波器组
        self.filters_real = nn.Parameter(self._create_erb_filters(n_erb, n_fft, fs, 'real'))
        self.filters_imag = nn.Parameter(self._create_erb_filters(n_erb, n_fft, fs, 'imag'))
        
    def forward(self, stft_complex):
        # stft_complex: [B, F, T, 2]  F=257
        # 分别对实部和虚部应用ERB滤波
        real_part = torch.einsum('bf,bft->bet', self.filters_real, stft_complex[..., 0])
        imag_part = torch.einsum('bf,bft->bet', self.filters_imag, stft_complex[..., 1])
        
        # 组合为复数ERB表示
        erb_complex = torch.stack([real_part, imag_part], dim=-1)
        return erb_complex  # [B, E, T, 2]  E=32
```

### 2. 逆ERB变换

为了实现完美重建，GTCRN需要逆ERB变换：

```python
class IERBTransform(nn.Module):
    def __init__(self, n_erb=32, n_fft=512, fs=16000):
        super().__init__()
        # 计算伪逆滤波器组
        self.inv_filters = nn.Parameter(self._create_inverse_filters(n_erb, n_fft, fs))
        
    def forward(self, erb_complex):
        # erb_complex: [B, E, T, 2]  E=32
        # 恢复到全频带
        full_spectrum = torch.einsum('be,betc->bftc', self.inv_filters, erb_complex)
        return full_spectrum  # [B, F, T, 2]  F=257
```

### 3. 参数化的ERB学习

GTCRN的一个创新点是**可学习的ERB变换**：

```python
class LearnableERBTransform(nn.Module):
    def __init__(self, n_erb=32, n_fft=512):
        super().__init__()
        # 初始化ERB滤波器为可学习参数
        self.filters = nn.Parameter(torch.randn(n_erb, n_fft//2 + 1))
        
        # 约束：滤波器权重为正且归一化
        self.softplus = nn.Softplus()
        
    def forward(self, stft_spectrum):
        # 应用约束
        normalized_filters = F.normalize(self.softplus(self.filters), p=1, dim=1)
        
        # ERB变换
        erb_features = torch.einsum('ef,bftc->betc', normalized_filters, stft_spectrum)
        return erb_features
```

**优势**：允许网络根据具体任务学习最优的频带分组。

---

## 💡 为什么ERB对GTCRN至关重要？

### 1. 解决了根本矛盾

语音降噪面临的根本矛盾：
- **高分辨率需求**：需要精细的频率分析
- **低计算约束**：移动设备资源有限
- **感知质量要求**：结果要符合人耳听觉

ERB通过**有选择性的分辨率**解决了这个矛盾：
- 低频：高分辨率，捕捉基频和谐波
- 高频：低分辨率，节省计算资源

### 2. 提供了生理学先验

ERB不仅仅是数学变换，它编码了**人耳的听觉先验**：
- 临界带宽：决定频率分辨率的生理极限
- 掩蔽效应：强音对弱音的掩蔽模式
- 感知相关性：频带划分与听觉感知匹配

这些先验知识帮助网络更好地理解语音和噪声的特性。

### 3. 实现了多目标优化

ERB帮助GTCRN同时优化多个目标：

| 优化目标 | ERB的贡献 |
|----------|-----------|
| 计算效率 | 减少80%计算量 |
| 内存效率 | 减少75%内存占用 |
| 感知质量 | 符合人耳特性，提升主观评分 |
| 泛化能力 | 更鲁棒的频带表示 |

### 4. 证明了信号处理+ML的优势

GTCRN选择ERB而非纯学习的频带划分，体现了深刻的工程智慧：

> "不是所有问题都适合从头学习。信号处理的先验知识可以极大地减少学习负担，提高效率。"

---

## 🔬 ERB的实验验证

### 1. 消融实验设计

GTCRN论文中的消融实验证明了ERB的重要性：

| 配置 | 频带数 | PESQ | SI-SDR | 参数量 | MACs |
|------|-------|------|--------|-------|------|
| 全频带 | 257 | 3.25 | 15.2 | 280K | 200M |
| 线性压缩 | 64 | 3.30 | 15.8 | 120K | 80M |
| Mel压缩 | 64 | 3.35 | 16.0 | 120K | 80M |
| **ERB压缩** | **32** | **3.42** | **16.8** | **48K** | **33M** |

### 2. 感知实验验证

主观听力测试结果：

```python
subjective_scores = {
    "MOS (Mean Opinion Score)": {
        "无降噪": 1.8,
        "谱减法": 2.5,
        "RNNoise": 3.1,
        "GTCRN (ERB)": 3.7
    },
    "语音自然度": {
        "谱减法": 低,  # 音乐噪声问题
        "RNNoise": 中等,  # 残留噪声
        "GTCRN (ERB)": 高  # 更自然的语音
    }
}
```

### 3. 效率实验验证

在不同硬件平台上的性能：

| 平台 | 配置 | 实时性 | 功耗 |
|------|------|-------|------|
| 手机CPU | 全频带 | 否 | 高 |
| 手机CPU | ERB压缩 | **是** | **低** |
| 嵌入式DSP | 全频带 | 边缘 | 中等 |
| 嵌入式DSP | ERB压缩 | **轻松** | **很低** |

---

## 思考题

1. 为什么人耳的频率感知是非线性的？这种特性对语音增强有什么影响？

2. ERB频带划分相比线性划分的主要优势是什么？从计算效率和感知质量两个角度分析。

3. GTCRN选择可学习的ERB变换而非固定ERB，这种设计有什么优点和潜在问题？

4. 如果要将GTCRN应用到其他音频处理任务（如音乐分离），ERB频带划分是否仍然合适？为什么？

---

## 延伸阅读

- [Glasberg, B. R., & Moore, B. C. J. "Derivation of auditory filter shapes from notched-noise data"](https://www.auditory.org/meetings/asa95/abstracts/psych_pml3_1.html)
- [Moore, B. C. J. "An Introduction to the Psychology of Hearing"](https://www.sciencedirect.com/book/9780125056267/an-introduction-to-the-psychology-of-hearing)
- [ERB-rate scale implementation in audio processing](https://github.com/mpariente/pystoi)
