# 开发Windows C++应用的时候，我们在说什么？

## 序

未来可以想见要面对的新人开发可能会越来越多，但是我又不足以有全部的精力告诉各位，每一个开发的细节和编译的过程，而这些内容往往很难在书本上介绍到。

对于一名刚刚入行的开发人员来说，我想你有必要知道一些《C++ Primer》、《Effective C++》这样的编程圣经之外看不到的东西。这些知识对于很多开发大能来说显而易见，但是对于一个刚入行的人来说，却是看不见摸不着的一道坎。

这篇文章大概率有诸多纰漏，但是对于一名初学者来说想必已经够用，有部分地方可能会为了更好的理解，导致严重的失实，我会尽量在文章末尾娓娓道来。

且听我倒上一杯酒，娓娓道来。

## Windows 应用程序结构

从我们第一次上编程课的时候，可能你用的是vc 6.0，可能用的是Dev C++，可能用的是Visual Studio等等IDE，在我们写程序的时候其实非常简单，通常结构是:

```C++
#include "stdio.h"
int main(){

    ///函数内容，需要执行的部分
    //一般的程序 包含 顺序结构、分支结构、循环结构

    return 1;
}
```

但是实际上很多人并不知道自己在IDE(Integrated Development Environment 集成开发环境​​)中点击生成了之后做了什么事，我们在这里暂时对此事先按下不表，之后我们会介绍此事。

我们首先要知道，在windows下，一般我们说一个可执行的程序会由两部分组成，一部分是exe，一部分是dll。

你需要注意的内容，主要是以下几部分：

### main函数

main函数，这样一个我们最开始学习的，最不起眼的函数，则是整个程序的入口函数。不论你的应用程序需要如何执行，都需要从这个main函数里起始，然后再一步步申请内存。也就是说，有些时候当你不知道怎么调试的时候，可以从main函数里面开始。

### exe程序和dll库

一个可执行的文件，一般都只有(*注1)一个exe程序，其余的dll都需要exe通过静态链接和动态链接的方式引用。我们管那个exe叫可执行程序，管dll叫库。

它们之间的关系很好理解，可执行的程序是管理员，DLL就像是一个个的工具，管理员需要的时候，就调用一下DLL，不需要的时候就可以释放。exe可以独立执行，它会自己去申请内存，但是dll必须要被其他进程调用，才可以申请内存。

换句话说，dll和exe之间，最大的区别就是dll没有main函数，只能被调用，不能从某个函数自己走进来。(*注2)

### C++程序的编译过程

接下来会讲到静态链接、动态链接，在此之前，考虑到部分应届生对编译原理没有什么概念，容我简单说说C++应用程序的编译过程。

C++程序的编译过程是将源代码转换为可执行文件的流程：首先，​​预处理​​阶段处理#include和宏定义等指令，生成展开后的代码；接着，​​编译​​阶段将C++代码转换为与硬件相关的汇编语言；然后，​​汇编​​阶段把汇编代码翻译成机器码，生成目标文件；最后，​​链接​​阶段将所有目标文件和库合并，解析函数和变量引用，生成最终的可执行程序。整个过程将人类可读的代码逐步转化为计算机能直接运行的二进制文件。

### 静态链接和动态链接

开发DLL库的时候，常见到一个后缀为lib的文件，不知道这个文件是为什么而存在的。


#### 静态链接

​​是指将程序依赖的库代码在编译时直接复制到最终的可执行文件中，生成一个独立的、无需额外库文件即可运行的程序。具体来说：编译器在链接阶段会把目标文件（.o或.obj）和静态库（.a或.lib）中的代码合并，解析所有函数和变量引用，最终生成一个完整的、自包含的可执行文件，运行时不再依赖外部的库文件。这种方式会增大程序体积，但避免了动态库的兼容性和依赖问题。

简单一点说，你可以理解为静态链接就是很粗暴的直接将整个dll插入到exe应用程序中去，只是为了开发上的独立，而拆分了一个.lib文件出来。

#### 动态链接

​动态链接​​是指程序在编译时仅记录依赖的库信息（如函数名称），而库代码本身不会复制到可执行文件中。程序运行时，操作系统才会动态加载所需的共享库（如.dll或.so文件），将库中的代码映射到进程内存中供调用。这种方式减少了程序体积，多个程序可共享同一份库文件，但要求运行环境必须存在正确版本的库文件，否则程序将无法启动。

简单一点说，动态链接就是可以通过指针来调用的一组接口，当我需要的时候，我就可以通过接口的名称来申请一段，当我不需要的时候，我就可以通过类似删除指针的方式，把这段内存给清理掉。其中，直接使用类似QLibrary 或者 LoadLibrary 接口调用库的方式，就是动态调用类C接口的方式。


```C++
// Math.dll 中的函数
__declspec(dllexport) int Add(int a, int b) {
    return a + b;
}
```

```C++
#include <windows.h>
#include <iostream>

typedef int (*AddFunc)(int, int); // 定义函数指针类型

int main() {
    // 1. 加载DLL（类似"点外卖"）
    HMODULE hDll = LoadLibrary("Math.dll");
    if (!hDll) {
        std::cerr << "无法加载DLL！" << std::endl;
        return 1;
    }

    // 2. 获取函数地址（通过函数名"下单"）
    AddFunc Add = (AddFunc)GetProcAddress(hDll, "Add");
    if (!Add) {
        std::cerr << "找不到函数！" << std::endl;
        FreeLibrary(hDll); // 释放DLL
        return 1;
    }

    // 3. 调用函数（"取餐"）
    int result = Add(2, 3); // 调用DLL中的Add函数
    std::cout << "结果: " << result << std::endl; // 输出: 5

    // 4. 卸载DLL（"清理订单"）
    FreeLibrary(hDll);
    return 0;
}

```

容易混淆的一点是，动态链接还包含了一种方式，就是.lib + .dll的形式，也是我们最常用的形式。

比如
``` C++
A.h     // 头文件
A.lib   //链接信息文件
A.dll   //库内容
```

在我们开发一个exe 的时候，常常会需要A.h和A.lib，而不需要A.dll。当使用应用程序的时候，往往就需要A.dll，而不需要A.h和A.lib。

其原因就是，A.lib中，包含了A.dll中所有的接口信息，而exe在编译的时候只需要知道A.dll的接口信息，以便于它在运行的时候可以找到对应的接口就行了。

为什么会有一个看上去这么畸形的方式呢？你只需要记住这回事就可以了，如果硬要说区别

1. LoadLibrary这种方式只能调用具体的接口，而使用A.lib的方式，则可以传递类等复杂变量作为参数。

2. 使用LoadLibrary就非常方便，而且即使A.dll不存在，exe也可以正常运行，但是如果使用.lib作为链接器的话，则必须要A.dll存在才可以运行exe。

这实际上是一个非常有意思的问题，如果感兴趣的话，我建议你去深入研究一下。


### Windows下如何导出DLL的接口？

我将打开一个Qt的基础项目，告诉你在Windows下的动态链接库是怎么导出接口的，分为两种情况，一是导出纯C接口，二是导出动态链接库的接口

```C++
// 纯C接口导出：Math.dll 中的函数，在Windows 下的编译器，MSVC下，需要使用__declspec(dllexport)这个指令来修饰接口，这样就可以将这个接口以类C接口的形式导出，在exe中，就可以以LoadLibrary的方式调用这个接口了。
// 导出 C 风格函数（兼容性更好）
extern "C" MATHDLL_EXPORT int add(int a, int b);

```


```C++
// MathDll.h
#pragma once
#ifdef Q_OS_WIN
    #define Q_DECL_EXPORT __declspec(dllexport)
    #define Q_DECL_IMPORT __declspec(dllimport)

//你在项目中，需要定义一个MATHDLL_LIB
#ifdef MATHDLL_LIB
#define MATHDLL_EXPORT Q_DECL_EXPORT  // Qt 的导出宏
#else
#define MATHDLL_EXPORT Q_DECL_IMPORT  // Qt 的导入宏
#endif

// 导出类（可选）
//当你在编译的时候，MATHDLL_EXPORT = Q_DECL_EXPORT __declspec(dllexport)
//当你在引用的时候，MATHDLL_EXPORT = Q_DECL_IMPORT __declspec(dllimport)
class MATHDLL_EXPORT MathUtils {
public:
    static int add(int a, int b);
};



```

